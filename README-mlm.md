## In a mlm system how points are calculated?

## Level
> **Level Upgrades:**
> 1. There must be a minimum of 2 members in both B and C levels, not counting unilateral referrals (meaning both B and C levels must have members).
> 2. If any Level 1 or Level 2-3 members withdraw funds and leave with an account balance below the minimum recharge of $50 within 96 hours, they will be considered inactive lower-level members and will be downgraded to the corresponding level.


| Personal Level | Required Points | Valid Grade A Referred | Valid Grade B and C Referred | Notes                            | Assets Held |
|----------------|------------------|--------------------------|-------------------------------|----------------------------------|--------------|
| LV1            | /                | /                        | /                             |                                  | 50           |
| LV2            | 50               | 3                        | 5                             | Number of team members: 8        | 500          |
| LV3            | 100              | 6                        | 20                            | Number of team members: 26       | 2000         |
| LV4            | 200              | 15                       | 35                            | Number of team members: 50       | 5000         |
| LV5            | 300              | 25                       | 70                            | Number of team members: 95       | 10000        |
| LV6            | 500              | 35                       | 180                           | Number of team members: 215      | 30000        |


## Cash Withdrawal Limit
> The second withdrawal can only be initiated after the arrival of the first withdrawal, each withdrawal fee of 5% Withdrawal within 96 hours to the account, the minimum withdrawal amount from 50. See chart for details:

| Personal Level | Assets Held |
|----------------|-------------|
| LV1            | 500         |
| LV2            | 1000        |
| LV3            | 3000        |
| LV4            | 5000        |
| LV5            | 10000       |
| LV6            | 20000       |


## Earnings by Level
These are the rights and benefits for users at different levels on the TreasureNFT platform.

| Rights                | LV0     | LV1       | LV2         | LV3           | LV4            | LV5              | LV6              |
|-----------------------|---------|-----------|-------------|---------------|----------------|------------------|------------------|
| Reservation Per Day   | 1       | 1         | 1           | 1             | 1              | 1                | 1                |
| Price Range of Auction| $1-50   | $50-1000  | $500-2,000  | $2,000-5,000  | $5,000-10,000  | $10,000-30,000   | $30,000-50,000   |
| Minting               | /       | /         | /           | /             | âˆš              | âˆš                | âˆš                |
| Novice Zone Task      | âˆš       | /         | /           | /             | /              | /                | /                |

### Descriptions of Rights and Earnings:
1. Different levels of users can make different numbers of reservations per day. As the user's level upgrades, they can make more reservations and choose from more price ranges, thus resulting in a higher income.
2. **Minting:** Users can apply for the right to participate in the issuance of NFTs.
3. **Novice Zone Task:** After new users register their accounts, they can trade in the novice zone.

---

## Getting Points

### 1. Platform Points
TreasureNFT platform points are divided into **daily task points** and **achievement task points**. As long as users participate in the TreasurNFT ecosystem, they can get the corresponding points. After completing tasks such as **signing in**, **reserving NFTs**, **minting NFTs**, **promoting the platform**, **placing orders** and **trading**, users can obtain the corresponding points which will continue to accumulate in their account. When users complete achievement tasks, they will get badges and points at different levels.

> Daily Task Pointsï¼šDaily tasks refresh every day and each task can only be completed once per day. For tasks that are not completed that day, the calculation for that task will be refreshed in next day.

| Task                                         | Condition      | Points |
|----------------------------------------------|----------------|--------|
| Complete Sign-in                             | âˆš              | 5      |
| Successful Reservation                       | âˆš              | 5      |
| Complete 1 Trade                             | âˆš              | 5      |
| User Transaction Amount (1 Day)              | $500+          | 5      |
| Number of Team Trades                        | 10 Times       | 5      |
| Team Transaction Amount                      | $2,000+        | 5      |
| Valid Grade A Referred                       | 1 Person       | 10     |
| Number of New Team Members Referred in 1 Day | 5 Persons      | 5      |
| Successfully Upgraded Personal Level Every Time | 1 Time      | 5      |


### 2. Achievement Task Points
| Task                                      | A Condition / Points | B Condition / Points | C Condition / Points |
|-------------------------------------------|-----------------------|-----------------------|-----------------------|
| Accumulated Sign-ins                      | 5 Days / 5            | 10 Days / 5           | 15 Days / 5           |
| Accumulated Consecutive Sign-ins          | 20 Days / 5           | 25 Days / 5           | 30 Days / 5           |
| Accumulated Successful Reservations       | 3 Times / 5           | 7 Times / 5           | 10 Times / 5          |
| Accumulated Successful Trades             | 5 Times / 5           | 15 Times / 5          | 20 Times / 10         |
| Accumulated Personal Transaction Amount   | $1,000 / 5            | $3,000 / 5            | $5,000 / 10           |
| Accumulated Number of Team Transactions   | 20 Times / 5          | 50 Times / 5          | 80 Times / 10         |
| Accumulated Team Transaction Amount       | $10,000 / 5           | $20,000 / 5           | $30,000 / 10          |
| Accumulated Valid Grade A Referrals       | 10 People / 5         | 20 People / 5         | 30 People / 10        |
| Accumulated Valid Grade B and C Referrals | 30 People / 5         | 50 People / 5         | 80 People / 10        |


---

## How points calculate in a MLM system?
In a Multi-Level Marketing (MLM) system, **points (or business volume, BV, commissionable volume, CV, etc.)** are often calculated to track sales, rewards, rank progress, and commission eligibility. The exact calculation depends on the MLM company's compensation plan, but here's a general breakdown of how points are typically calculated:


### ðŸ”¸ 1. Types of Points Used
1. **Personal Volume (PV):**
   - Points generated by a user's own purchases or sales.
   - Used for personal rank qualification and commissions.
2. **Group Volume (GV):**
   - Sum of PV of the user and all their downlines (sometimes within a certain depth).
   - Used to calculate team bonuses and rank progression.
3. **Business Volume (BV):**
   - A standardized point value assigned to products (may differ from price).
   - Used to calculate commissions.
4. **Commissionable Volume (CV):**
   - Portion of BV that is actually eligible for commission distribution (after deductions).
5. **Matching Volume (MV):**
   - Used in binary or matrix plans to match volume from left/right or different legs.


### ðŸ”¸ 2. Point Calculation Example
Assume a product worth $100 has:
- BV: 80
- CV: 70
- Retail Price: $100
When a user (say User A) buys this:
- **User A earns:** 80 PV (personal volume)
- **Upline (User B) earns:** 80 BV added to downline group volume
- **Commission distribution** is calculated from CV (70)


### ðŸ”¸ 3. How Points Flow in Hierarchy
Letâ€™s say the structure is:
````sql
User A (buys product with 80 BV)
|
User B (direct upline)
|
User C
````
- **User A**: Gets 80 PV and maybe a personal rebate.
- **User B**: Gets 80 BV from User A (if 1st level eligible).
- **User C**: Also may get 80 BV if multiple-levels are rewarded.

**Depending on the MLM** plan (unilevel, binary, matrix, etc.), different uplines receive the volume.


### ðŸ”¸ 4. Rank-Based Point Thresholds
MLM systems often have rank configurations, like:

| Rank   | Required PV | Required GV | Additional Rules            |
| ------ | ----------- | ----------- | --------------------------- |
| Bronze | 100         | 500         | At least 2 direct referrals |
| Silver | 200         | 1500        | 2 downlines at Bronze rank  |
| Gold   | 300         | 3000        | 3 downlines at Silver rank  |

### ðŸ”¸ 5. Binary/Multi-leg Point Matching (if applicable)
In binary plans, points are tracked in Left and Right legs:
- If left = 1000 BV and right = 800 BV â†’ 800 BV is matched â†’ commission is based on 800
- Remaining 200 BV in left leg may be carried forward


### ðŸ”¸ 6. Common Rules for Point Validity
- Points may **expire** after a certain time if no rank progression.
- Volume may be **flushed** if user is inactive.
- Volume from **non-qualified** members may be excluded.



---
## âœ… Summary
| Type            | Generated From      | Used For                       |
| --------------- | ------------------- | ------------------------------ |
| PV (Personal)   | Own purchases       | Rank eligibility, bonuses      |
| GV (Group)      | Downline PV         | Team bonuses, rank progression |
| BV (Business)   | Product point value | Commission calculation         |
| CV (Commission) | Portion of BV       | Commission payout              |


---

## Entity's:

### âœ… 1. User Entity
````java
@Entity
public class User {
    @Id
    private Long id;
    private String username;
    private String rankCode;

    @ManyToOne
    @JoinColumn(name = "referrer_id")
    private User referrer;

    private LocalDateTime registeredAt;
    private boolean active;
}
````

### âœ… 2. UserHierarchy (Closure Table for efficient depth-based queries)
````java
@Entity
public class UserHierarchy {
    @Id
    @GeneratedValue
    private Long id;

    @ManyToOne
    @JoinColumn(name = "ancestor_id")
    private User ancestor;

    @ManyToOne
    @JoinColumn(name = "descendant_id")
    private User descendant;

    private int depth; // 0 = self, 1 = direct, 2 = indirect
}
````

### âœ… 3. InvestmentPlan (with BV and PV)
````java
@Entity
public class InvestmentPlan {
    @Id
    private Long id;

    private String name;

    private BigDecimal price;

    private int bv; // Business Volume

    private int pv; // Personal Volume

    private boolean active;
}
````

### âœ… 4. UserInvestment (records user purchases)
````java
@Entity
public class UserInvestment {
    @Id
    private Long id;

    @ManyToOne
    private User user;

    @ManyToOne
    private InvestmentPlan plan;

    private LocalDateTime investedAt;

    private boolean active;
}
````

### âœ… 5. UserPointSummary (calculated & cached points)
````java
@Entity
public class UserPointSummary {
    @Id
    private Long id;

    @OneToOne
    private User user;

    private int totalPV; // Sum of own PV

    private int totalBV; // Sum of own BV

    private int totalGV; // Group volume (includes downlines)
}
````

### âœ… 6. Point Calculation Logic (Sample Service Skeleton)
````java
@Service
public class PointCalculationService {

    @Autowired
    private UserInvestmentRepository investmentRepo;

    @Autowired
    private UserHierarchyRepository hierarchyRepo;

    public void calculateUserPoints(Long userId) {
        User user = userRepo.findById(userId).orElseThrow();

        int pv = investmentRepo.sumPVByUser(user);
        int bv = investmentRepo.sumBVByUser(user);

        // Downline points
        List<User> downlines = hierarchyRepo.findDescendants(user.getId());
        int gv = investmentRepo.sumBVByUsers(downlines);

        UserPointSummary summary = pointRepo.findByUser(user)
            .orElse(new UserPointSummary());
        summary.setUser(user);
        summary.setTotalPV(pv);
        summary.setTotalBV(bv);
        summary.setTotalGV(gv);
        pointRepo.save(summary);
    }
}
````

### âœ… 7. Example BV Flow
- **User A** buys Plan X (BV = 100)
- **User B** is direct upline â†’ gets 100 added to GV
- **User C** is above User B â†’ also gets 100 added to GV (if within rewardable depth)

### âœ… Optional: RankConfig Table
To define thresholds like this:

| Rank    | Min PV | Min GV | Min Downlines |
| ------- | ------ | ------ | ------------- |
| RANK\_1 | 100    | 1000   | 2 at RANK\_1  |
| RANK\_2 | 300    | 3000   | 3 at RANK\_1  |

You can evaluate ranks using a `RankEvaluatorService`.

````java
@Entity
public class RankConfig {
    @Id
    private String rankCode;

    private int minPV;
    private int minGV;
    private int minDirectsAtRank;
}
````

## Sample Data:

### âœ… Sample Data: Users & Hierarchy
| ID | Username | Referrer | Rank    |
| -- | -------- | -------- | ------- |
| 1  | Alice    | null     | RANK\_1 |
| 2  | Bob      | Alice    | RANK\_1 |
| 3  | Carol    | Bob      | RANK\_0 |
| 4  | Dave     | Bob      | RANK\_0 |
â†’ Closure table (UserHierarchy) will generate entries like:
- (1, 1, 0), (1, 2, 1), (1, 3, 2), (1, 4, 2)
- (2, 2, 0), (2, 3, 1), (2, 4, 1)
- etc.

### âœ… Sample Investment Plans
| ID | Name         | Price | BV  | PV  |
| -- | ------------ | ----- | --- | --- |
| 1  | Basic Plan   | 100   | 50  | 50  |
| 2  | Premium Plan | 200   | 100 | 100 |

### âœ… Sample User Investments
| User  | Plan         | Date       |
| ----- | ------------ | ---------- |
| Carol | Basic Plan   | 2025-08-01 |
| Dave  | Premium Plan | 2025-08-02 |
| Bob   | Premium Plan | 2025-08-03 |

### âœ… Expected Points:
**For Carol:**
- PV = 50, BV = 50, GV = 0

**For Bob:**
- PV = 100, BV = 100
- GV = Carol (50) + Dave (100) = 150

**For Alice:**
- PV = 0, BV = 0
- GV = Bob (100) + Carol (50) + Dave (100) = 250


---

## âœ… Sample SQL Queries (H2/PostgreSQL)
Sum PV/BV of user:
````sql
SELECT SUM(ip.pv), SUM(ip.bv)
FROM user_investment ui
JOIN investment_plan ip ON ui.plan_id = ip.id
WHERE ui.user_id = :userId;
````

Sum GV (all descendants):
````sql
SELECT SUM(ip.bv)
FROM user_investment ui
JOIN investment_plan ip ON ui.plan_id = ip.id
WHERE ui.user_id IN (
    SELECT descendant_id FROM user_hierarchy
    WHERE ancestor_id = :userId AND depth > 0
);
````

---
### âœ… 1. Java Code to Distribute Commission
````java
@Service
public class CommissionDistributionService {

    @Autowired private UserHierarchyRepository hierarchyRepo;
    @Autowired private WalletService walletService;
    @Autowired private UserInvestmentRepository investmentRepo;
    @Autowired private CommissionRateConfig commissionConfig; // Map<Integer level, BigDecimal percent>

    public void distributeCommission(UserInvestment investment) {
        List<UserHierarchy> uplines = hierarchyRepo.findAncestorsByDescendant(investment.getUser().getId());

        BigDecimal totalAmount = investment.getPlan().getBvAmount(); // e.g., 100 BV
        for (UserHierarchy uplineLink : uplines) {
            int level = uplineLink.getDepth();
            BigDecimal rate = commissionConfig.getRateForLevel(level);
            if (rate != null && rate.compareTo(BigDecimal.ZERO) > 0) {
                BigDecimal commission = totalAmount.multiply(rate);
                walletService.creditCommission(uplineLink.getAncestor(), commission, level);
            }
        }
    }
}
````

### âœ… 2. Java Code to Evaluate Rank
````java
@Service
public class RankEvaluationService {

    @Autowired private RankConfigRepository rankRepo;
    @Autowired private UserPointSummaryRepository summaryRepo;
    @Autowired private UserRepository userRepo;

    public void evaluateAndUpdateRank(User user) {
        UserPointSummary summary = summaryRepo.findByUser(user).orElse(null);
        if (summary == null) return;

        List<RankConfig> allRanks = rankRepo.findAllByOrderByPriorityDesc();
        for (RankConfig rank : allRanks) {
            if (summary.getTotalPV() >= rank.getMinPV() &&
                summary.getTotalGV() >= rank.getMinGV()) {
                user.setRankCode(rank.getRankCode());
                userRepo.save(user);
                return;
            }
        }
    }
}
````

### âœ… 3. REST API to View Point Summaries
````java
@RestController
@RequestMapping("/api/v1/points")
public class PointSummaryController {

    @Autowired private UserPointSummaryRepository summaryRepo;

    @GetMapping("/{userId}")
    public ResponseEntity<UserPointSummaryDto> getSummary(@PathVariable Long userId) {
        return summaryRepo.findByUserId(userId)
                .map(summary -> ResponseEntity.ok(new UserPointSummaryDto(summary)))
                .orElse(ResponseEntity.notFound().build());
    }
}
````
### DTO:
````java
public class UserPointSummaryDto {
    private Long userId;
    private int totalPV;
    private int totalBV;
    private int totalGV;

    public UserPointSummaryDto(UserPointSummary s) {
        this.userId = s.getUser().getId();
        this.totalPV = s.getTotalPV();
        this.totalBV = s.getTotalBV();
        this.totalGV = s.getTotalGV();
    }
}
````

## âœ… 4. React Dashboard â€“ User Tree with Points
Component: `UserTreeWithPoints.jsx`
````jsx
import React, { useEffect, useState } from 'react';
import axios from 'axios';

const TreeNode = ({ node }) => (
  <div className="ms-3 mt-2 border-start ps-2">
    <strong>{node.username}</strong> â€” PV: {node.totalPV}, GV: {node.totalGV}
    {node.children && node.children.map(child => (
      <TreeNode key={child.userId} node={child} />
    ))}
  </div>
);

const UserTreeWithPoints = ({ userId }) => {
  const [tree, setTree] = useState(null);

  useEffect(() => {
    axios.get(`/api/v1/users/${userId}/tree-with-points`)
      .then(res => setTree(res.data));
  }, [userId]);

  return (
    <div>
      <h4>User Tree with Points</h4>
      {tree ? <TreeNode node={tree} /> : <p>Loading...</p>}
    </div>
  );
};

export default UserTreeWithPoints;
````
### âœ… 5. Cron Job to Update Points and Ranks
````java
@Service
public class CronJobService {

    @Autowired private UserRepository userRepo;
    @Autowired private PointCalculationService pointCalcService;
    @Autowired private RankEvaluationService rankService;

    @Scheduled(cron = "0 0 1 * * *") // every day at 1AM
    public void updateAllUsers() {
        List<User> users = userRepo.findAll();
        for (User user : users) {
            pointCalcService.calculateUserPoints(user.getId());
            rankService.evaluateAndUpdateRank(user);
        }
    }
}
````